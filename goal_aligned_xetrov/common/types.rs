use super::linalg::vector2d::{EPSILON, Vec2D};
use super::utilities::types::HasScenario;
use super::utilities::rng_utilities::{random_tau, random_unity};

use std::cmp::Ordering::Equal;

// Distance to which potential spreads from obstacles.
pub const POTENTIAL_SCALE: f64 = 10f64;

// Look ahead time for vehicles.
pub const LOOK_AHEAD: f64 = 0.5f64;

// Implementers of HasSource can return the nearest point on their geometry.
pub trait HasSource {
    fn source(&self, v: Vec2D) -> Vec2D;
}

// Arrangement of vehicle and discs to be used in benchmarks.
pub struct Scenario { pub vehicle: Vehicle
                    , pub obstacles: Vec<Box<HasSource>> }

impl HasScenario for Scenario {
    // Returns the interactions between the vehicle and obstacles in the
    // scenario.
    fn interactions(&self) -> u32 {
        let mut count = 0;
        let point = self.vehicle.look_ahead();
        for obstacle in self.obstacles.iter() {
            if self.vehicle.potential(point, obstacle).is_some() {
                count += 1;
            }
        }
        count
    }

    // Returns the avoidance force to be applied to the vehicle according to
    // the steering scenario.
    fn avoidance(&self) -> Option<Vec2D> {
        self.vehicle.total_potential(&self.obstacles)
    }
}

impl Scenario {
    // Creates a scenario from the given vehicle and obstacles.
    pub fn new(vehicle: Vehicle, obstacles: Vec<Box<HasSource>>) -> Scenario {
        Scenario { vehicle: vehicle, obstacles: obstacles }
    }
}

// Vehicle that steers using goal-aligned xetrov field.
pub struct Vehicle { pub position:        Vec2D
                   , pub velocity:        Vec2D
                   , pub potential_scale: f64 }

impl HasSource for Vehicle {
    // Returns the future position of this vehicle.
    #[allow(unused_variables)]
    fn source(&self, v: Vec2D) -> Vec2D {
        self.look_ahead()
    }
}

impl Vehicle {
    // Creates a vehicle from the given values.
    pub fn new(pos: Vec2D, vel: Vec2D, potential_scale: f64) -> Vehicle {
        Vehicle { position:        pos
                , velocity:        vel
                , potential_scale: potential_scale }
    }

    // Returns the 'look ahead' position of the vehicle.
    pub fn look_ahead(&self) -> Vec2D {
        self.position.add(self.velocity.mul(LOOK_AHEAD))
    }

    // Returns the potential corresponding to the given disc.
    pub fn potential(&self, point: Vec2D, disc: &Box<HasSource>)
        -> Option<(Vec2D, f64)>
    {
        // Determine repulsor.
        let source = disc.source(point);
        let mut repulsor = source.sub(point);
        let distance = repulsor.mag();

        // Determine nature of interaction.
        if distance < EPSILON { return None; }
        if distance >= self.potential_scale { return None; }
        let ratio = distance / self.potential_scale;

        // Calculate components of potential.
        let gd = (1f64 - ratio) * (1f64 - ratio);
        let hd = ratio.sqrt();
        let zd = ((1f64 - hd) * (1f64 - hd) + hd * hd).sqrt();
        let rd = gd * (1f64 - hd) / zd;
        let td = gd * hd / zd;

        // Determine basis and calculate potential.
        repulsor = repulsor.mul(1f64 / distance);
        let mut tangent = repulsor.perp();
        if tangent.dot(self.velocity) < 0f64 { tangent = tangent.neg(); }
        Some((repulsor.mul(rd).add(tangent.mul(td)), gd))
    }

    // Returns the potential generated by the given discs.
    pub fn total_potential(&self, discs: &Vec<Box<HasSource>>)
        -> Option<Vec2D>
    {
        // Evaluate potential for all discs.
        let point = self.look_ahead();
        let mut potentials = vec!();
        for disc in discs.iter() {
            if let Some(v) = self.potential(point, disc) {
                potentials.push(v);
            }
        }

        // Sort potentials by magnitude.
        if potentials.len() == 0 { return None; }
        potentials.sort_by(|a, b| {
            (a.1).partial_cmp(&(b.1)).unwrap_or(Equal)
        });

        // Accumulate potentials.
        let mut result = Vec2D::zero();
        let mut remaining = 1f64;

        for potential in potentials.iter() {
            if potential.1 > remaining {
                let scale = remaining / potential.1;
                let result = result.add(potential.0.mul(scale));
                return Some(result);
            }

            result = result.add(potential.0);
            remaining -= potential.1;
        }
        Some(result.mul(self.potential_scale))
    }
}

// Returns a vehicle with semi-random position and velocity and a fixed
// potential scale.
#[warn(dead_code)]
pub fn random_vehicle() -> Vehicle {
    let angle = random_tau();
    let position = Vec2D::polar(angle, 100f64 * random_unity());
    let velocity = Vec2D::polar(angle, 10f64);
    Vehicle::new(position, velocity, POTENTIAL_SCALE)
}
