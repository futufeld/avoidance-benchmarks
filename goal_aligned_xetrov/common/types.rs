use super::linalg::vector2d::*;
use super::utilities::handler::*;

use std::cmp::Ordering::Equal;

// Distance to which potential spreads from obstacles.
pub const POTENTIAL_SCALE: f64 = 10f64;

// Look ahead time for vehicles.
pub const LOOK_AHEAD: f64 = 0.5f64;

// Implementers of HasSource can return the nearest point on their geometry.
pub trait HasSource {
    fn source(&self, v: Vec2D) -> Vec2D;
}

// Vehicle that steers using goal-aligned xetrov field.
pub struct Vehicle {
    pub position: Vec2D,
    pub velocity: Vec2D,
    pub potential_scale: f64
}

impl HasSource for Vehicle {
    // Return the future position of this vehicle.
    #[allow(unused_variables)]
    fn source(&self, v: Vec2D) -> Vec2D {
        self.look_ahead()
    }
}

impl Vehicle {
    // Creates a vehicle from the given values.
    pub fn new(pos: Vec2D, vel: Vec2D, potential_scale: f64) -> Vehicle {
        Vehicle { position: pos
                , velocity: vel
                , potential_scale: potential_scale }
    }

    // Returns the 'look ahead' position of the vehicle.
    pub fn look_ahead(&self) -> Vec2D {
        self.position.add(self.velocity.mul(LOOK_AHEAD))
    }

    // Returns the potential corresponding to the given disc.
    pub fn potential(&self, point: Vec2D, disc: &Box<HasSource>)
        -> Option<Vec2D>
    {
        // Determine repulsor.
        let source = disc.source(point);
        let mut repulsor = source.sub(point);
        let distance = repulsor.mag();

        // Determine nature of interaction.
        if distance < EPSILON { return None; }
        if distance >= self.potential_scale { return None };
        let ratio = distance / self.potential_scale;

        // Calculate components of potential.
        let gd = (1f64 - ratio) * (1f64 - ratio);
        let hd = ratio.sqrt();
        let zd = ((1f64 - hd) * (1f64 - hd) + hd * hd).sqrt();
        let rd = gd * (1f64 - hd) / zd;
        let td = gd * hd / zd;

        // Determine basis and calculate potential.
        repulsor = repulsor.mul(1f64 / distance);
        let mut tangent = repulsor.perp();
        if tangent.dot(self.velocity) < 0f64 {
            tangent = tangent.neg();
        }
        Some(repulsor.mul(rd).add(tangent.mul(td)))
    }

    // Returns the potential generated by the given discs.
    pub fn total_potential(&self, discs: &Vec<Box<HasSource>>)
        -> Option<Vec2D>
    {
        // Evaluate potential for all discs.
        let point = self.look_ahead();
        let mut potentials = vec!();
        for disc in discs.iter() {
            match self.potential(point, disc) {
                Some(v) => potentials.push(v),
                None => ()
            };
        }

        // Sort potentials by magnitude.
        if potentials.len() == 0 { return None };
        let mut potentials_with_mag: Vec<(Vec2D, f64)> =
            potentials.iter().map(|&x| (x, x.mag())).collect();
        potentials_with_mag.sort_by(|a, b| {
            (a.1).partial_cmp(&(b.1)).unwrap_or(Equal)
        });

        // Accumulate potentials.
        let mut result = Vec2D::zero();
        let mut remaining = 1f64;

        for potential in potentials_with_mag.iter() {
            if potential.1 > remaining {
                let scale = remaining / potential.1;
                let result = result.add(potential.0.mul(scale))
                                   .mul(self.potential_scale);
                return Some(result);
            }

            result = result.add(potential.0);
            remaining -= potential.1;
        }
        Some(result.mul(self.potential_scale))
    }
}

// Arrangement of vehicle and discs to be used in benchmarks.
pub struct Scenario {
    pub vehicle: Vehicle,
    pub obstacles: Vec<Box<HasSource>>
}

impl HasScenario for Scenario {
    // Runs the scenario.
    fn run(&mut self) {
        let _ = self.vehicle.total_potential(&self.obstacles);
    }
}

impl Scenario {
    // Creates a scenario from the given vehicle and obstacles.
    pub fn new(vehicle: Vehicle, obstacles: Vec<Box<HasSource>>) -> Scenario {
        Scenario { vehicle: vehicle, obstacles: obstacles }
    }
}
