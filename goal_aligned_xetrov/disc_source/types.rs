use super::linalg::vector2d::*;
use super::linalg::matrix2d::*;

use std::cmp::Ordering::Equal;

// Look ahead time.
const LOOK_AHEAD: f64 = 0.5f64;

// Vehicle that steers using goal-aligned xetrov field.
pub struct Vehicle {
    pub position: Vec2D,
    pub velocity: Vec2D,
    pub potential_scale: f64
}

impl Vehicle {
    // Creates a vehicle from the given values.
    pub fn new(pos: Vec2D, vel: Vec2D, potential_scale: f64) -> Vehicle {
        Vehicle { position: pos
                , velocity: vel
                , potential_scale: potential_scale }
    }

    // Returns the 'look ahead' position of the vehicle.
    pub fn look_ahead(&self) -> Vec2D {
        self.position.add(self.velocity.mul(LOOK_AHEAD))
    }

    // Returns the potential corresponding to the given disc.
    pub fn potential(&self, point: Vec2D, disc: &Disc) -> Option<Vec2D> {
        // Determine repulsor.
        let source = match disc.source(point) {
            SourceResult::Case1(x) => x,
            SourceResult::Case2(x) => x
        };
        let mut repulsor = point.sub(source);
        let distance = repulsor.mag();

        // Determine nature of interaction.
        if distance < EPSILON { return None; }
        if distance > self.potential_scale { return None; }
        let ratio = distance / self.potential_scale;

        // Calculate components of potential.
        let gd = (1f64 - ratio) * (1f64 - ratio);
        let hd = ratio.sqrt();
        let zd = (1f64 - hd) * (1f64 - hd) + hd * hd;
        let rd = gd * ((1f64 - hd) / zd);
        let td = gd * (hd / zd);

        // Determine basis and calculate potential.
        repulsor = repulsor.mul(1f64 / distance);
        let mut tangent = repulsor.perp();
        if tangent.dot(self.velocity) < 0f64 {
            tangent = tangent.neg();
        }
        Some(repulsor.mul(rd).add(tangent.mul(td)))
    }

    // Returns the potential generated by the given discs.
    pub fn total_potential(&self, discs: &Vec<Disc>) -> Option<Vec2D> {
        // Evaluate potential for all discs.
        let point = self.look_ahead();
        let mut potentials = vec!();
        for disc in discs.iter() {
            match self.potential(point, disc) {
                Some(v) => potentials.push(v),
                None => ()
            };
        }

        // Sort potentials by magnitude.
        if potentials.len() == 0 { return None };
        let mut potentials_with_mag: Vec<(Vec2D, f64)> =
            potentials.iter().map(|&x| (x, x.mag())).collect::<Vec<_>>();
        potentials_with_mag.sort_by(|a ,b| {
            (a.1).partial_cmp(&(b.1)).unwrap_or(Equal)
        });

        // Combine potentials.
        let mut result = Vec2D::zero();
        let mut remaining = 1f64;

        for potential in potentials_with_mag.iter() {
            if potential.1 > remaining {
                let scale = remaining / potential.1;
                let result = result.add(potential.0.mul(scale))
                                   .mul(self.potential_scale);
                return Some(result);
            }

            result = result.add(potential.0);
            remaining -= potential.1;
        }
        Some(result.mul(self.potential_scale))
    }
}

// Defines transforms in and out of a space containing a disc.
pub struct Disc {
    pub to_world: Mat2D,
    pub to_local: Mat2D,
    pub radius: f64
}

// Case identified when determining the source on a disc.
pub enum SourceResult {
    Case1(Vec2D),
    Case2(Vec2D)
}

impl Disc {
    // Creates a disc from a position and radius.
    pub fn new(pos: Vec2D, radius: f64) -> Disc {
        let to_world = Mat2D::identity().shift(pos);
        let to_local = Mat2D::identity().shift(pos.neg());
        Disc { to_world: to_world, to_local: to_local, radius: radius }
    }

    // Returns the source corresponding to `v`.
    pub fn source(&self, v: Vec2D) -> SourceResult {
        let local = self.to_local.transform(v);
        let mag = local.mag();
        if mag <= self.radius {
            SourceResult::Case1(self.to_world.transform(v))
        } else {
            let source = local.mul(self.radius / mag);
            SourceResult::Case2(self.to_world.transform(source))
        }
    }
}
